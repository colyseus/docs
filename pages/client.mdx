import { Callout, Cards, Tabs } from "nextra/components";
import { ZapIcon, SyncIcon } from "@primer/octicons-react";

# Client SDK

<Cards>
    <Cards.Card icon={<ZapIcon/>} title="Getting Started" href="/getting-started" />
    <Cards.Card icon={<SyncIcon />} title="State Sync Callbacks" href="/client/state-sync-callbacks" />
</Cards>

## Overview

Every client SDK provides the same set of methods and events to interact with the server.

- [Client](#client) - The SDK entrypoint
- [Room](#room) - Room connection.
- [HTTP Requests](#http-requests) - Utility to perform HTTP requests.
- [Auth](/auth/module#frontend-api) _(Optional)_ - Authentication module.

## Client

The `Client` instance is the entrypoint to connect to the server. It is used to create or join rooms, and perform HTTP requests.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    import { Client } from "@colyseus/sdk";
    // ...

    let client = new Client("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    import Colyseus from "@colyseus/sdk";
    // ...

    let client = new Colyseus.Client("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    using Colyseus;
    // ...

    ColyseusClient client = new ColyseusClient("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    local ColyseusClient = require("colyseus.client")
    -- ...

    local client = ColyseusClient.new("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    import io.colyseus.Client;
    // ...

    var client = new Client("http://localhost:2567");
    ```
    </Tabs.Tab>

</Tabs>

### Methods

#### Join or Create a Room

Join an existing room or create a new one, by provided `roomName` and `options`.

```ts filename="Signature"
client.joinOrCreate (roomName: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.joinOrCreate("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.joinOrCreate("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.JoinOrCreate<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:join_or_create("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.joinOrCreate("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->joinOrCreate<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>

</Tabs>

<Callout type="info">
    Locked or private rooms are ignored by this method.
</Callout>

#### Create a Room

Creates a new room by provided `roomName` and `options`.

```ts filename="Signature"
client.create (roomName: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.create("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.create("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.Create<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:create("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.create("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->create<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

#### Join existing Room

Joins an existing room by provided `roomName` and `options`.

```ts filename="Signature"
client.join (roomName: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.join("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.join("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.Join<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:join("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.join("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->join<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    Locked or private rooms are ignored by this method.
</Callout>

#### Join Room by ID

Joins an existing room by its `roomId`. Private rooms can be joined by id.

```ts filename="Signature"
client.joinById (roomId: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.joinById("KRYAKzRo2", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.joinById("KRYAKzRo2", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.JoinById<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:join_by_id("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.joinById("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->joinById<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

#### Reconnect into a Room

Reconnects the client back into a previously connected room.

- You must store/cache the `room.reconnectionToken` from an active room connection to be able to reconnect.
- To enable the reconnection of a particular client, the server needs to call [`.allowReconnection()`](/server/room#allowreconnection-client-seconds) for that client instance.

```ts filename="Signature"
client.reconnect (reconnectionToken)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.reconnect(cachedReconnectionToken);
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.reconnect(cachedReconnectionToken).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.Reconnect<YourStateClass>(cachedReconnectionToken);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:reconnect(cached_reconnection_token, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.reconnect(cachedReconnectionToken, YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->reconnect<YourStateClass>(cachedReconnectionToken, [=](std::string err, Room<State>* room) {
    if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
    }

    std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

#### Consume Seat Reservation

Join a room by manually consuming a "seat reservation".

```ts filename="Signature"
client.consumeSeatReservation (reservation)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.consumeSeatReservation(reservation);
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.consumeSeatReservation(reservation).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.ConsumeSeatReservation<YourStateClass>(reservation);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:consume_seat_reservation(reservation, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.consumeSeatReservation(reservation, YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->consumeSeatReservation<YourStateClass>(reservation, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    **Advanced usage** - See [Match-maker API](/server/matchmaker/#reserveseatforroom-options) to learn how to manually reserve a seat for a client within a room.
</Callout>

---

#### Get Latency

Create a temporary connection with the server and measure the latency. Returns a promise that resolves to the average latency in milliseconds.

```ts filename="Signature"
client.getLatency (options?: LatencyOptions): Promise<number>
```

**Parameters**

- `options.pingCount`: Number of pings to send (default: `1`). Returns the average latency when greater than 1.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    const latency = await client.getLatency();
    console.log("Latency:", latency, "ms");

    // With multiple pings for a more accurate average
    const avgLatency = await client.getLatency({ pingCount: 5 });
    console.log("Average Latency:", avgLatency, "ms");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.getLatency().then((latency) => {
      console.log("Latency:", latency, "ms");
    });

    // With multiple pings for a more accurate average
    client.getLatency({ pingCount: 5 }).then((avgLatency) => {
      console.log("Average Latency:", avgLatency, "ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    float latency = await client.GetLatency();
    Debug.Log("Latency: " + latency + " ms");

    // With multiple pings for a more accurate average
    float avgLatency = await client.GetLatency(new LatencyOptions { PingCount = 5 });
    Debug.Log("Average Latency: " + avgLatency + " ms");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:get_latency(function(err, latency)
      print("Latency: " .. latency .. " ms")
    end)

    -- With multiple pings for a more accurate average
    client:get_latency({ ping_count = 5 }, function(err, avg_latency)
      print("Average Latency: " .. avg_latency .. " ms")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.getLatency(function(err, latency) {
      trace("Latency: " + latency + " ms");
    });

    // With multiple pings for a more accurate average
    client.getLatency({ pingCount: 5 }, function(err, avgLatency) {
      trace("Average Latency: " + avgLatency + " ms");
    });
    ```
    </Tabs.Tab>
</Tabs>

---

#### Select By Latency (Static)

Select the endpoint with the lowest latency from a list of endpoints. This is useful for connecting to the best server when you have multiple server deployments across different regions.

```ts filename="Signature"
Client.selectByLatency (endpoints: Array<string | EndpointSettings>): Promise<Client>
```

**Parameters**

- `endpoints`: Array of server endpoints (URLs or endpoint settings objects).
- `options`: Optional client options to pass to each client instance.
- `latencyOptions.pingCount`: Number of pings to send per endpoint (default: `1`).

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    import { Client } from "@colyseus/sdk";

    // Select the best server from multiple regions
    const client = await Client.selectByLatency([
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com",
    ]);

    // Now use the client with the lowest latency
    const room = await client.joinOrCreate("game");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    import Colyseus from "@colyseus/sdk";

    // Select the best server from multiple regions
    Colyseus.Client.selectByLatency([
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com",
    ]).then((client) => {
      // Now use the client with the lowest latency
      return client.joinOrCreate("game");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    using Colyseus;

    // Select the best server from multiple regions
    ColyseusClient client = await ColyseusClient.SelectByLatency(new string[] {
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com"
    });

    // Now use the client with the lowest latency
    Room<YourStateClass> room = await client.JoinOrCreate<YourStateClass>("game");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    local ColyseusClient = require("colyseus.client")

    -- Select the best server from multiple regions
    ColyseusClient.select_by_latency({
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com"
    }, function(err, client)
      -- Now use the client with the lowest latency
      client:join_or_create("game", {}, function(err, room)
        print("joined successfully")
      end)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    import io.colyseus.Client;

    // Select the best server from multiple regions
    Client.selectByLatency([
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com"
    ], function(err, client) {
      // Now use the client with the lowest latency
      client.joinOrCreate("game", [], YourStateClass, function(err, room) {
        trace("joined successfully");
      });
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    The method logs the latency for each endpoint to the console for debugging purposes. If all endpoints fail to respond, an error is thrown.
</Callout>

## Room

### Properties

#### `state: any`

The current room's state. This variable is always synched with the latest `state` from the server. To listen for updates on the whole state, see [`onStateChange`](#on-state-change) event.

For fine-grained control over state updates, see [State Synchronization → Schema Callbacks](/state/callbacks).

---

#### `sessionId: string`

Unique identifier for the current connected client. This property matches the [`client.sessionId`](/server/room#client/#sessionid-string) from the server.

---

#### `id: string`

The unique idenfitier of the room. You can share this id with other clients in
order to allow them to connect directly to this room.

```js filename="client.js"
// get `roomId` from the query string
let roomId = location.href.match(/roomId=([a-zA-Z0-9\-_]+)/)[1];

// joining a room by its id
client.joinById(roomId).then(room => {
  // ...
});
```

---

#### `name: string`

Name of the room handler. Ex: `"battle"`.

---

### Methods

#### Send Message

Send a type of message to the room handler. Messages are encoded with MsgPack and can hold any JSON-serializable data structure.

```ts filename="Signature"
room.send (type, message)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    //
    // sending message with string type
    //
    room.send("move", { direction: "left"});

    //
    // sending message with number type
    //
    room.send(0, { direction: "left"});
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    //
    // sending message with string type
    //
    room.send("move", { direction: "left"});

    //
    // sending message with number type
    //
    room.send(0, { direction: "left"});
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    //
    // sending message with string type
    //
    await room.Send("move", new { direction = "left" });

    //
    // sending message with number type
    //
    await room.Send(0, new { direction = "left" });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    --
    -- sending message with string type
    --
    room:send("move", { direction = "left" })

    --
    -- sending message with number type
    --
    room:send(0, { direction = "left" })
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    //
    // sending message with string type
    //
    room.send("move", { direction: "left" });

    //
    // sending message with number type
    //
    room.send(0, { direction: "left" });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    **Use `Room#onMessage()` from the backend to receive the messages** - Check out [Room API → onMessage](/server/room/#on-message) section.
</Callout>

---

#### Send Message (in bytes)

Send a raw byte array as a message to the server. A byte array is an array of numbers from `0` to `255`.

This is useful if you'd like to manually encode a message, rather than the default encoding (MsgPack).

```ts filename="Signature"
client.sendBytes (type, bytes)
```

    ```js filename="client.js"
    //
    // sending message with number type
    //
    room.sendBytes(0, [ 172, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33 ]);


    //
    // sending message with string type
    //
    room.sendBytes("some-bytes", [ 172, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33 ]);
    ```

---

#### Leave Room

Disconnect client from the room.

```ts filename="Signature"
room.leave (consented: boolean)
```

**Parameters**

- `consented`: Whether the act of leaving has been "consented" or not (Default is `true`)

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    // consented leave
    room.leave();

    // force unconsented leave
    room.leave(false);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    // consented leave
    room.leave();

    // force unconsented leave
    room.leave(false);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    // consented leave
    room.Leave();

    // unconsented leave
    room.Leave(false);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    -- consented leave
    room:leave()

    -- unconsented leave
    room:leave(false)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    // consented leave
    room.leave();

    // unconsented leave
    room.leave(false);
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    Use [Room API → onLeave](/server/room/#on-message) to handle the disconnection from the backend.
</Callout>

---

#### Ping

Measure the round-trip time (RTT) latency between the client and the server in milliseconds. The callback is invoked with the latency value once the server responds.

```ts filename="Signature"
room.ping (callback: (ms: number) => void)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.ping((latency) => {
      console.log("Latency:", latency, "ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.ping((latency) => {
      console.log("Latency:", latency, "ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.Ping((latency) => {
      Debug.Log("Latency: " + latency + " ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:ping(function(latency)
      print("Latency: " .. latency .. " ms")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.ping(function(latency) {
      trace("Latency: " + latency + " ms");
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    If the connection is not open, calling `ping()` has no effect.
</Callout>

---

#### Remove All Listeners

Removes `onMessage`, `onStateChange`, `onLeave` and `onError` listeners.

```ts filename="Signature"
room.removeAllListeners()
```

---

### Events

#### On Message

This event is triggered when the server sends a message directly to the client, or via broadcast.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onMessage("powerup", (message) => {
      console.log("message received from server");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onMessage("powerup", (message) => {
      console.log("message received from server");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    class PowerUpMessage {
      string kind;
    }

    room.OnMessage<PowerUpMessage>("powerup", (message) => {
      Debug.Log ("message received from server");
      Debug.Log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on_message("powerup", function(message)
      print("message received from server")
      print(message)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onMessage("powerup", function(message) {
      trace("message received from server");
      trace(Std.string(message));
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onMessage("powerup", [=](msgpack::object message) -> void {
        std::cout << "message received from server" << std::endl;
        std::cout << message << std::endl;
    });
    ```
    </Tabs.Tab>

</Tabs>

<Callout type="info">
    To send a message from the server directly to the clients you'll need to use either [client.send()](/server/room#client/#sendtype-message) or [room.broadcast()](/server/room/#broadcast-type-message-options)
</Callout>

---

#### On Leave

This event is triggered when the client leave the room.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onLeave((code) => {
      console.log("client left the room");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onLeave((code) => {
      console.log("client left the room");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnLeave += (code) => {
      Debug.Log ("client left the room");
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("leave", function()
      print("client left the room")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onLeave += function () {
      trace("client left the room");
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onLeave = [=]() -> void {
      std::cout << "client left the room" << std::endl;
    };
    ```
    </Tabs.Tab>
</Tabs>

**Possible closing `code`s and their meaning:**

- `1000` - Regular socket shutdown
- Between `1001` and `1015` - Abnormal socket shutdown
- Between `4000` and `4999` - Custom socket close code (See [more details](/server/room/#table-of-websocket-close-codes))


---

#### On State Change

This event is triggered whenever the server's state is synchronized with the client. It occurs both when the client first connects to the room and when state updates are sent by the server

For fine-grained control over state updates, you should use the [schema callbacks](/state/callbacks).

<Callout type="info">
    Check out the [State Synchronization » Schema Callbacks](/state/callbacks) section for more details.
</Callout>

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onStateChange.once((state) => {
      console.log("this is the first room state!", state);
    });

    room.onStateChange((state) => {
      console.log("the room state has been updated:", state);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onStateChange.once((state) => {
      console.log("this is the first room state!", state);
    });

    room.onStateChange((state) => {
      console.log("the room state has been updated:", state);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnStateChange += (state, isFirstState) => {
      if (isFirstState) {
        Debug.Log ("this is the first room state!");
      }

      Debug.Log ("the room state has been updated");
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("statechange", function(state)
      print("new state:", state)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onStateChange += function(state) {
      trace("new state:" + Std.string(state));
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onStateChange = [=](State>* state) {
      std::cout << "new state" << std::endl;
      // ...
    };
    ```
    </Tabs.Tab>
</Tabs>

---


#### On Error

This event is triggered when some error occurs in the room handler.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onError((code, message) => {
      console.log("oops, error ocurred:");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onError((code, message) => {
      console.log("oops, error ocurred:");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnError += (code, message) => {
      Debug.Log ("oops, error ocurred:");
      Debug.Log(message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("error", function(code, message)
      print("oops, error ocurred:")
      print(message)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onError += function(code, message) {
      trace("oops, error ocurred:");
      trace(message);
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onError = [=] (int code, std::string message) => void {
      std::cout << "oops, error ocurred: " << message << std::endl;
    };
    ```
    </Tabs.Tab>
</Tabs>

---

## HTTP Requests

The `client.http` utility can perform HTTP requests to your server endpoint.

<Callout type="info">
    The `client.auth.token` property is sent automatically as `Authorization` header in all HTTP requests. See [Authentication → HTTP Middleware](/auth/http) for more details.
</Callout>

### GET

Perform a GET request to the server.

<Tabs items={["Client", "Server"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.get("/profile").then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    // ...
        express: (app) => {
            app.get("/profile", (req, res) => {
                res.json({ name: "Jake Badlands" });
            });
        },
    // ...
    ```
    </Tabs.Tab>
</Tabs>

### POST

Perform a POST request to the server.

<Tabs items={["Client", "Server"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.post("/profile", { body: { name: "Jake Badlands" } }).then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    // ...
        express: (app) => {
            app.post("/profile", (req, res) => {
                res.json(req.body);
            });
        },
    // ...
    ```
    </Tabs.Tab>
</Tabs>


### DELETE

Perform a DELETE request to the server.

<Tabs items={["Client", "Server"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.delete("/profile").then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    // ...
        express: (app) => {
            app.delete("/profile", (req, res) => {
                res.json({ deleted: true });
            });
        },
    // ...
    ```
    </Tabs.Tab>
</Tabs>

### PUT

Perform a PUT request to the server.

<Tabs items={["Client", "Server"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.put("/profile", { body: { name: "Jake Badlands" } }).then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    // ...
        express: (app) => {
            app.put("/profile", (req, res) => {
                res.json(req.body);
            });
        },
    // ...
    ```
    </Tabs.Tab>
</Tabs>

---

## Next Steps

- [State Callbacks](/state/callbacks) - Listen for state changes on the client
- [Room API](/room) - Server-side room implementation
- [Authentication](/auth) - Secure your room connections
- [Tutorials](/tutorial) - Step-by-step game implementations
