import { Callout, Cards, Tabs } from "nextra/components";
import { ZapIcon, SyncIcon, ServerIcon, PasskeyFillIcon } from "@primer/octicons-react";
import { SDKTabs } from "../components/SDKTabs"

# Client SDK

<Cards>
    <Cards.Card icon={<ZapIcon/>} title="Getting Started" href="/getting-started" />
    <Cards.Card icon={<SyncIcon />} title="State Sync Callbacks" href="/client/state-sync-callbacks" />
</Cards>

The Client SDK provides everything you need to connect to a Colyseus server from your game or application.

---

## Set Up

The `Client` instance is your entry point to connect to the server.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    import { Client } from "@colyseus/sdk";
    const client = new Client("http://localhost:2567");

    // ... with full-stack type safety (optional)
    import type { server } from "../../server/src/app.config.ts";
    const client = new Client<typeof server>("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    import Colyseus from "@colyseus/sdk";

    const client = new Colyseus.Client("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    using Colyseus;

    ColyseusClient client = new ColyseusClient("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    local ColyseusClient = require("colyseus.client")

    local client = ColyseusClient.new("http://localhost:2567");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    import io.colyseus.Client;

    var client = new Client("http://localhost:2567");
    ```
    </Tabs.Tab>

</Tabs>

---

## Connecting to Rooms

Once you have a client, you can connect to rooms. Choose the method that best fits your matchmaking needs.

### Join or Create (Recommended)

The most common way to connect. Joins an existing room if available, or creates a new one.

```ts filename="Signature"
client.joinOrCreate (roomName: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.joinOrCreate("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.joinOrCreate("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.JoinOrCreate<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:join_or_create("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.joinOrCreate("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->joinOrCreate<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>

</Tabs>

<Callout type="info">
    Locked or private rooms are ignored by this method.
</Callout>

### Create a New Room

Always creates a new room instance, even if others exist.

```ts filename="Signature"
client.create (roomName: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.create("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.create("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.Create<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:create("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.create("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->create<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
  You may dissallow the client from creating rooms. See [Matchmaker → API Restricting the frontend from creating rooms](/matchmaker#restricting-the-frontend-from-creating-rooms)
</Callout>

### Join an Existing Room

Joins an existing room by room name. Fails if no room is available.

```ts filename="Signature"
client.join (roomName: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.join("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.join("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.Join<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:join("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.join("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->join<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    Locked or private rooms are ignored by this method.
</Callout>

### Join by Room ID

Joins a specific room by its unique ID. This is useful for invite links or rejoining a specific game. **Private rooms can be joined by ID.**

```ts filename="Signature"
client.joinById (roomId: string, options: any)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.joinById("KRYAKzRo2", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.joinById("KRYAKzRo2", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.JoinById<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:join_by_id("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.joinById("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->joinById<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

**Example: Creating an invite link**

```js filename="client.js"
// Share the room ID with other players
const inviteLink = `https://mygame.com/join?roomId=${room.roomId}`;

// On the receiving end, parse the room ID and join
let roomId = location.href.match(/roomId=([a-zA-Z0-9\-_]+)/)[1];
client.joinById(roomId).then(room => {
  // ...
});
```

### Consume Seat Reservation

Join a room using a pre-reserved seat.

A **"seat reservation"** is a token generated by the server that allows a client to join a specific room instance. This is useful for scenarios where you want to control access to rooms, such as private matches or matchmaking systems.

```ts filename="Signature"
client.consumeSeatReservation (reservation)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.consumeSeatReservation(reservation);
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.consumeSeatReservation(reservation).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.ConsumeSeatReservation<YourStateClass>(reservation);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:consume_seat_reservation(reservation, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.consumeSeatReservation(reservation, YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->consumeSeatReservation<YourStateClass>(reservation, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
  A "seat reservation" can be obtained from the backend using the Match-maker API. See [Match-maker API → Reserve Seat For](/matchmaker#reserve-a-seat-for)
</Callout>

---

## Send and Receive Messages

Once connected to a room, you can send and receive messages in real-time.

### Send Message

Send messages to the room handler. Messages are encoded with MsgPack and can hold any JSON-serializable data.

```ts filename="Signature"
room.send (type, message)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    //
    // sending message with string type
    //
    room.send("move", { direction: "left"});

    //
    // sending message with number type
    //
    room.send(0, { direction: "left"});
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    //
    // sending message with string type
    //
    room.send("move", { direction: "left"});

    //
    // sending message with number type
    //
    room.send(0, { direction: "left"});
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    //
    // sending message with string type
    //
    await room.Send("move", new { direction = "left" });

    //
    // sending message with number type
    //
    await room.Send(0, new { direction = "left" });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    --
    -- sending message with string type
    --
    room:send("move", { direction = "left" })

    --
    -- sending message with number type
    --
    room:send(0, { direction = "left" })
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    //
    // sending message with string type
    //
    room.send("move", { direction: "left" });

    //
    // sending message with number type
    //
    room.send(0, { direction: "left" });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    **Backend:** See [Room → Message Handling](/room#message-handling) for detailed documentation on receiving messages from the client.
</Callout>

### Send Raw Bytes

For custom encoding, send raw byte arrays (numbers from `0` to `255`).

```ts filename="Signature"
room.sendBytes (type, bytes)
```

```js filename="client.js"
//
// sending message with number type
//
room.sendBytes(0, [ 172, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33 ]);

//
// sending message with string type
//
room.sendBytes("some-bytes", [ 172, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33 ]);
```

### On Message

Listen for messages sent from the server.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onMessage("powerup", (message) => {
      console.log("message received from server");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onMessage("powerup", (message) => {
      console.log("message received from server");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    class PowerUpMessage {
      string kind;
    }

    room.OnMessage<PowerUpMessage>("powerup", (message) => {
      Debug.Log ("message received from server");
      Debug.Log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on_message("powerup", function(message)
      print("message received from server")
      print(message)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onMessage("powerup", function(message) {
      trace("message received from server");
      trace(Std.string(message));
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onMessage("powerup", [=](msgpack::object message) -> void {
        std::cout << "message received from server" << std::endl;
        std::cout << message << std::endl;
    });
    ```
    </Tabs.Tab>

</Tabs>

<Callout type="info">
    **Backend:** To send a message from the server to a client you'll need to use either [client.send()](/room#send-message) or [room.broadcast()](/room/#broadcast-message)
</Callout>

---

## State Synchronization

The room state is automatically synchronized from the server to all connected clients.

### Accessing Room State

The `room.state` property always contains the latest synchronized state from the server.

```ts filename="Signature"
room.state: any
```

### On State Change

The `onStateChange` event fires whenever the server synchronizes state updates.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onStateChange.once((state) => {
      console.log("this is the first room state!", state);
    });

    room.onStateChange((state) => {
      console.log("the room state has been updated:", state);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onStateChange.once((state) => {
      console.log("this is the first room state!", state);
    });

    room.onStateChange((state) => {
      console.log("the room state has been updated:", state);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnStateChange += (state, isFirstState) => {
      if (isFirstState) {
        Debug.Log ("this is the first room state!");
      }

      Debug.Log ("the room state has been updated");
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("statechange", function(state)
      print("new state:", state)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onStateChange += function(state) {
      trace("new state:" + Std.string(state));
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onStateChange = [=](State>* state) {
      std::cout << "new state" << std::endl;
      // ...
    };
    ```
    </Tabs.Tab>
</Tabs>

### State Sync Callbacks

For better performance and control, listen to specific property changes instead of the entire state.

<SDKTabs>
    <Tabs.Tab>
    ```ts {10} filename="client.ts"
    // get state callbacks handler
    const callbacks = Callbacks.get(room);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs {10} filename="client.cs"
    // get state callbacks handler
    var callbacks = Colyseus.Schema.Callbacks.Get(room);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua {10} filename="client.lua"
    -- get state callbacks handler
    local callbacks = ColyseusSDK.callbacks(room)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe {2,11} filename="client.hx"
    import io.colyseus.serializer.schema.Callbacks;

    // get state callbacks handler
    var callbacks = Callbacks.get(room);
    ```
    </Tabs.Tab>
</SDKTabs>

<Callout type="info">
    Check out the [Client SDK → State Sync Callbacks](/sdk/state-sync-callbacks) section for detailed documentation on listening to specific state changes.
</Callout>

<Callout type="info">
    Read more about [<SyncIcon/> State Sychronization](/state)
</Callout>

---

## Connection Lifecycle

Handle the various states of a room connection.

### Leaving a Room

Disconnect from the room. Use `consented: true` (default) for intentional leaves, or `false` to simulate an unexpected disconnect.

```ts filename="Signature"
room.leave (consented: boolean)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    // consented leave
    room.leave();

    // force unconsented leave
    room.leave(false);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    // consented leave
    room.leave();

    // force unconsented leave
    room.leave(false);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    // consented leave
    room.Leave();

    // unconsented leave
    room.Leave(false);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    -- consented leave
    room:leave()

    -- unconsented leave
    room:leave(false)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    // consented leave
    room.leave();

    // unconsented leave
    room.leave(false);
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    **Backend:** Use [Room → On Leave](/room#on-leave) to handle client disconnection.
</Callout>

### On Leave Event

Triggered when the client leaves the room (either intentionally or due to disconnection).

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onLeave((code) => {
      console.log("client left the room");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onLeave((code) => {
      console.log("client left the room");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnLeave += (code) => {
      Debug.Log ("client left the room");
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("leave", function()
      print("client left the room")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onLeave += function () {
      trace("client left the room");
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onLeave = [=]() -> void {
      std::cout << "client left the room" << std::endl;
    };
    ```
    </Tabs.Tab>
</Tabs>

**Possible closing `code`s and their meaning:**

- `1000` - Regular socket shutdown
- Between `1001` and `1015` - Abnormal socket shutdown
- Between `4000` and `4999` - Custom socket close code (See [more details](/room/#table-of-websocket-close-codes))

### Automatic Reconnection

The SDK automatically attempts to reconnect when the connection is unexpectedly dropped.

<Callout type="warning">
    Automatic reconnection only triggers if the room has been connected for at least `minUptime` milliseconds. This prevents reconnection loops for rooms that fail immediately after joining.
</Callout>

#### On Drop Event

Triggered when the connection is unexpectedly dropped. The SDK will automatically attempt to reconnect.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onDrop((code, reason) => {
      console.log("connection dropped, attempting to reconnect...");
      console.log("code:", code, "reason:", reason);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onDrop((code, reason) => {
      console.log("connection dropped, attempting to reconnect...");
      console.log("code:", code, "reason:", reason);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnDrop += (code, reason) => {
      Debug.Log("connection dropped, attempting to reconnect...");
      Debug.Log("code: " + code + " reason: " + reason);
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("drop", function(code, reason)
      print("connection dropped, attempting to reconnect...")
      print("code:", code, "reason:", reason)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onDrop += function(code, reason) {
      trace("connection dropped, attempting to reconnect...");
      trace("code: " + code + " reason: " + reason);
    };
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    The `onDrop` event is different from `onLeave`. While `onLeave` is triggered when the client intentionally leaves or the connection is permanently closed, `onDrop` indicates a temporary disconnection where reconnection will be attempted.
</Callout>

<Callout type="info">
    **Close codes that trigger `onDrop`:**
    - `1005` - No status received
    - `1006` - Abnormal closure
    - `1001` - Going away
    - `4010` - May try reconnect
</Callout>

#### On Reconnect Event

Triggered when the client successfully reconnects after a connection drop. While disconnected, your `room.send()` calls will be queued and sent to the server when the client reconnects. The maximum number of queued messages is configurable using `room.reconnection.maxEnqueuedMessages`.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onReconnect(() => {
      console.log("successfully reconnected to the room!");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onReconnect(() => {
      console.log("successfully reconnected to the room!");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnReconnect += () => {
      Debug.Log("successfully reconnected to the room!");
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("reconnect", function()
      print("successfully reconnected to the room!")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onReconnect += function() {
      trace("successfully reconnected to the room!");
    };
    ```
    </Tabs.Tab>
</Tabs>

#### Configuration Options

You may configure the reconnection behavior using `room.reconnection`.

**Reconnection config options**

| Option | Default | Description |
|--------|---------|-------------|
| `maxRetries` | `15` | Maximum reconnection attempts |
| `minDelay` | `100` | Minimum delay between attempts (ms) |
| `maxDelay` | `5000` | Maximum delay between attempts (ms) |
| `minUptime` | `5000` | Minimum room uptime before reconnection is allowed (ms) |
| `delay` | `100` | Initial delay between attempts (ms) |
| `maxEnqueuedMessages` | `10` | Maximum buffered messages during reconnection |
| `backoff` | exponential | Delay calculation function |

**Status properties** _(read-only)_

| Property | Type | Description |
|----------|------|------------|
| `isReconnecting` | boolean | Whether currently reconnecting |
| `retryCount` | number | Current reconnection attempt count |
| `enqueuedMessages` | number | Buffered messages |


**Customizing reconnection behavior:**

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    const room = await client.joinOrCreate("battle");

    // Customize reconnection options
    room.reconnection.maxRetries = 10;
    room.reconnection.maxDelay = 10000; // 10 seconds max delay
    room.reconnection.minUptime = 3000; // Allow reconnection after 3 seconds
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.joinOrCreate("battle").then(room => {
      // Customize reconnection options
      room.reconnection.maxRetries = 10;
      room.reconnection.maxDelay = 10000; // 10 seconds max delay
      room.reconnection.minUptime = 3000; // Allow reconnection after 3 seconds
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    Room<YourStateClass> room = await client.JoinOrCreate<YourStateClass>("battle");

    // Customize reconnection options
    room.Reconnection.MaxRetries = 10;
    room.Reconnection.MaxDelay = 10000; // 10 seconds max delay
    room.Reconnection.MinUptime = 3000; // Allow reconnection after 3 seconds
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:join_or_create("battle", {}, function(err, room)
      -- Customize reconnection options
      room.reconnection.max_retries = 10
      room.reconnection.max_delay = 10000 -- 10 seconds max delay
      room.reconnection.min_uptime = 3000 -- Allow reconnection after 3 seconds
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.joinOrCreate("battle", [], YourStateClass, function(err, room) {
      // Customize reconnection options
      room.reconnection.maxRetries = 10;
      room.reconnection.maxDelay = 10000; // 10 seconds max delay
      room.reconnection.minUptime = 3000; // Allow reconnection after 3 seconds
    });
    ```
    </Tabs.Tab>
</Tabs>

**Custom backoff function:**

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.reconnection.backoff = (attempt: number, delay: number) => {
      return Math.floor(Math.pow(2, attempt) * delay);
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.reconnection.backoff = (attempt, delay) => {
      return Math.floor(Math.pow(2, attempt) * delay);
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.Reconnection.Backoff = (attempt, delay) => {
      return (int)Math.Floor(Math.Pow(2, attempt) * delay);
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room.reconnection.backoff = function(attempt, delay)
      return math.floor(math.pow(2, attempt) * delay)
    end
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.reconnection.backoff = function(attempt:Int, delay:Int):Int {
      return Math.floor(Math.pow(2, attempt) * delay);
    };
    ```
    </Tabs.Tab>
</Tabs>

### Manual Reconnection

For more control, you can manually reconnect using a cached reconnection token. Because this method returns a new room instance on the client, you must reattach all event listeners to the room after reconnecting.

- You must store/cache the `room.reconnectionToken` from an active room connection.
- The server needs to call [`.allowReconnection()`](/room#allow-reconnection) for that client.

```ts filename="Signature"
client.reconnect (reconnectionToken)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>

    <Tabs.Tab>
    ```ts filename="client.ts"
    try {
      const room = await client.reconnect(cachedReconnectionToken);
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.reconnect(cachedReconnectionToken).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    try {
      Room<YourStateClass> room = await client.Reconnect<YourStateClass>(cachedReconnectionToken);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:reconnect(cached_reconnection_token, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.reconnect(cachedReconnectionToken, YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    client->reconnect<YourStateClass>(cachedReconnectionToken, [=](std::string err, Room<State>* room) {
    if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
    }

    std::cout << "joined successfully" << std::endl;
    });
    ```
    </Tabs.Tab>
</Tabs>

### Error Handling

Listen for errors that occur in the room.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.onError((code, message) => {
      console.log("oops, error ocurred:");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.onError((code, message) => {
      console.log("oops, error ocurred:");
      console.log(message);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.OnError += (code, message) => {
      Debug.Log ("oops, error ocurred:");
      Debug.Log(message);
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:on("error", function(code, message)
      print("oops, error ocurred:")
      print(message)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.onError += function(code, message) {
      trace("oops, error ocurred:");
      trace(message);
    };
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cpp filename="client.cpp"
    room.onError = [=] (int code, std::string message) => void {
      std::cout << "oops, error ocurred: " << message << std::endl;
    };
    ```
    </Tabs.Tab>
</Tabs>

### Removing Listeners

Remove all event listeners from the room.

```ts filename="Signature"
room.removeAllListeners()
```

---

## Latency & Server Selection

Measure network latency and choose optimal servers for your players.

### Measuring Latency

#### On the Client

Create a temporary connection to measure latency before joining a room.

```ts filename="Signature"
client.getLatency (options?: LatencyOptions): Promise<number>
```

**Parameters**

- `options.pingCount`: Number of pings to send (default: `1`). Returns the average latency when greater than 1.

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    const latency = await client.getLatency();
    console.log("Latency:", latency, "ms");

    // With multiple pings for a more accurate average
    const avgLatency = await client.getLatency({ pingCount: 5 });
    console.log("Average Latency:", avgLatency, "ms");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    client.getLatency().then((latency) => {
      console.log("Latency:", latency, "ms");
    });

    // With multiple pings for a more accurate average
    client.getLatency({ pingCount: 5 }).then((avgLatency) => {
      console.log("Average Latency:", avgLatency, "ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    float latency = await client.GetLatency();
    Debug.Log("Latency: " + latency + " ms");

    // With multiple pings for a more accurate average
    float avgLatency = await client.GetLatency(new LatencyOptions { PingCount = 5 });
    Debug.Log("Average Latency: " + avgLatency + " ms");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    client:get_latency(function(err, latency)
      print("Latency: " .. latency .. " ms")
    end)

    -- With multiple pings for a more accurate average
    client:get_latency({ ping_count = 5 }, function(err, avg_latency)
      print("Average Latency: " .. avg_latency .. " ms")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    client.getLatency(function(err, latency) {
      trace("Latency: " + latency + " ms");
    });

    // With multiple pings for a more accurate average
    client.getLatency({ pingCount: 5 }, function(err, avgLatency) {
      trace("Average Latency: " + avgLatency + " ms");
    });
    ```
    </Tabs.Tab>
</Tabs>

#### On an Active Room

Measure round-trip time on an existing connection.

```ts filename="Signature"
room.ping (callback: (ms: number) => void)
```

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    room.ping((latency) => {
      console.log("Latency:", latency, "ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    room.ping((latency) => {
      console.log("Latency:", latency, "ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    room.Ping((latency) => {
      Debug.Log("Latency: " + latency + " ms");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    room:ping(function(latency)
      print("Latency: " .. latency .. " ms")
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    room.ping(function(latency) {
      trace("Latency: " + latency + " ms");
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    If the connection is not open, calling `ping()` has no effect.
</Callout>

### Multi-Region Server Selection

Automatically connect to the server with the lowest latency from a list of endpoints.

```ts filename="Signature"
Client.selectByLatency (endpoints: Array<string | EndpointSettings>): Promise<Client>
```

**Parameters**

- `endpoints`: Array of server endpoints (URLs or endpoint settings objects).
- `options`: Optional client options to pass to each client instance.
- `latencyOptions.pingCount`: Number of pings to send per endpoint (default: `1`).

<Tabs items={["TypeScript", "JavaScript", "C#", "Lua", "Haxe"]} storageKey='sdk-tab-language'>
    <Tabs.Tab>
    ```ts filename="client.ts"
    import { Client } from "@colyseus/sdk";

    // Select the best server from multiple regions
    const client = await Client.selectByLatency([
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com",
    ]);

    // Now use the client with the lowest latency
    const room = await client.joinOrCreate("game");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```js filename="client.js"
    import Colyseus from "@colyseus/sdk";

    // Select the best server from multiple regions
    Colyseus.Client.selectByLatency([
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com",
    ]).then((client) => {
      // Now use the client with the lowest latency
      return client.joinOrCreate("game");
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```cs filename="Client.cs"
    using Colyseus;

    // Select the best server from multiple regions
    ColyseusClient client = await ColyseusClient.SelectByLatency(new string[] {
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com"
    });

    // Now use the client with the lowest latency
    Room<YourStateClass> room = await client.JoinOrCreate<YourStateClass>("game");
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```lua filename="client.lua"
    local ColyseusClient = require("colyseus.client")

    -- Select the best server from multiple regions
    ColyseusClient.select_by_latency({
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com"
    }, function(err, client)
      -- Now use the client with the lowest latency
      client:join_or_create("game", {}, function(err, room)
        print("joined successfully")
      end)
    end)
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```haxe filename="client.hx"
    import io.colyseus.Client;

    // Select the best server from multiple regions
    Client.selectByLatency([
      "https://us-east.gameserver.com",
      "https://eu-west.gameserver.com",
      "https://asia.gameserver.com"
    ], function(err, client) {
      // Now use the client with the lowest latency
      client.joinOrCreate("game", [], YourStateClass, function(err, room) {
        trace("joined successfully");
      });
    });
    ```
    </Tabs.Tab>
</Tabs>

<Callout type="info">
    The method logs the latency for each endpoint to the console for debugging purposes. If all endpoints fail to respond, an error is thrown.
</Callout>

---

## HTTP Requests

The `client.http` utility performs HTTP requests to your server endpoint.

<Callout type="info">
    The `client.auth.token` property is sent automatically as `Authorization` header in all HTTP requests. See [<PasskeyFillIcon/> Authentication → HTTP Middleware](/auth/http) for more details.
</Callout>

<Callout type="info">
    See [<ServerIcon/> Server → HTTP Routes](/server/http-routes) for setting up HTTP endpoints on your server.
</Callout>

### GET

<Tabs items={["Client", "Server Route (recommended)", "Server (express)"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.get("/profile").then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer, createEndpoint } from "@colyseus/sdk";

    const server = defineServer({
        routes: createRouter({
            profile: createEndpoint("/profile", { method: "GET" }, (ctx) => {
                ctx.json({ name: "Jake Badlands" });
            })
        })
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer } from "@colyseus/sdk";

    const server = defineServer({
        express: (app) => {
            app.get("/profile", (req, res) => {
                res.json({ name: "Jake Badlands" });
            });
        },
    });
    ```
    </Tabs.Tab>
</Tabs>

### POST

<Tabs items={["Client", "Server Route (recommended)", "Server (express)"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.post("/profile", { body: { name: "Jake Badlands" } }).then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer, createEndpoint } from "@colyseus/sdk";

    const server = defineServer({
        routes: createRouter({
            profile: createEndpoint("/profile", { method: "POST" }, (ctx) => {
                ctx.json(ctx.body);
            })
        })
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer } from "@colyseus/sdk";

    const server = defineServer({
        express: (app) => {
            app.post("/profile", (req, res) => {
                res.json(req.body);
            });
        },
    });
    ```
    </Tabs.Tab>
</Tabs>

### PUT

<Tabs items={["Client", "Server Route (recommended)", "Server (express)"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.put("/profile", { body: { name: "Jake Badlands" } }).then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer, createEndpoint } from "@colyseus/sdk";

    const server = defineServer({
        routes: createRouter({
            profile: createEndpoint("/profile", { method: "PUT" }, (ctx) => {
                ctx.json(ctx.body);
            })
        })
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer } from "@colyseus/sdk";

    const server = defineServer({
        express: (app) => {
            app.put("/profile", (req, res) => {
                res.json(req.body);
            });
        },
    });
    ```
    </Tabs.Tab>
</Tabs>

### DELETE

<Tabs items={["Client", "Server Route (recommended)", "Server (express)"]}>
    <Tabs.Tab>
    ```js filename="client.js"
    client.http.delete("/profile").then((response) => {
        console.log(response.data);
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer, createEndpoint } from "@colyseus/sdk";

    const server = defineServer({
        routes: createRouter({
            profile: createEndpoint("/profile", { method: "DELETE" }, (ctx) => {
                ctx.json({ deleted: true });
            })
        })
    });
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```ts filename="src/app.config.ts"
    import { defineServer } from "@colyseus/sdk";

    const server = defineServer({
        express: (app) => {
            app.delete("/profile", (req, res) => {
                res.json({ deleted: true });
            });
        },
    });
    ```
    </Tabs.Tab>
</Tabs>

---

## Room Reference

Quick reference for room properties.

| Property | Type | Description |
|----------|------|-------------|
| `state` | `any` | The synchronized room state from the server |
| `sessionId` | `string` | Unique identifier for the current client connection |
| `roomId` | `string` | Unique room ID (shareable for direct joins) |
| `name` | `string` | Name of the room handler (e.g., `"battle"`) |
| `reconnectionToken` | `string` | Token for manual reconnection |
| `reconnection` | `ReconnectionOptions` | Automatic reconnection configuration |

---

## Next Steps

- [State Sync Callbacks](/sdk/state-sync-callbacks) - Listen for state changes on the client
- [Room API](/room) - Server-side room implementation
- [Authentication](/auth) - Secure your room connections
- [Tutorials](/tutorial) - Step-by-step game implementations
